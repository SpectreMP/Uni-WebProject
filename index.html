<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Math warriors</title>
    <script src="node_modules/phaser/dist/phaser.min.js"></script>
    <style type="text/css">
        body{
            margin: 0;
        }
    </style>
</head>
<body>
<script type="text/javascript">
var PLAYER;
var DEBUG = false;

class GameScene extends Phaser.Scene{
    preload(){
        this.load.spritesheet('vagabond', 'src/vagabond.png', {frameWidth:64});
        this.load.spritesheet('mannequin', 'src/mannequin.png', {frameWidth:48})

        this.load.image('base', 'src/SampleMap/[Base]BaseChip_pipo.png')
        this.load.image('water', 'src/SampleMap/[A]Water_pipo.png')
        this.load.image('grass', 'src/SampleMap/[A]Grass_pipo.png')
        this.load.image('flower', 'src/SampleMap/[A]Flower_pipo.png')
        this.load.tilemapTiledJSON('samplemap', 'src/SampleMap/samplemap.json')
    }
    create(){
        const map = this.add.tilemap('samplemap' );

        const baseSet = map.addTilesetImage('[Base]BaseChip_pipo', 'base');
        const waterSet = map.addTilesetImage('[A]Water_pipo', 'water');
        const grassSet = map.addTilesetImage('[A]Grass_pipo', 'grass');
        const flowerSet = map.addTilesetImage('[A]Flower_pipo', 'flower');

        const groundLayer = map.createLayer('ground', [baseSet, waterSet, grassSet, flowerSet]);
        const grassLayer = map.createLayer('grass', [baseSet, waterSet, grassSet, flowerSet]);
        const waterLayer = map.createLayer('water', [baseSet, waterSet, grassSet, flowerSet]);
        const waterGrassLayer = map.createLayer('water_grass', [baseSet, waterSet, grassSet, flowerSet]);
        const buildingLayer = map.createLayer('building', [baseSet, waterSet, grassSet, flowerSet]);
        const farmLayer = map.createLayer('farm', [baseSet, waterSet, grassSet, flowerSet]);
        const farmUpLayer = map.createLayer('farm_up', [baseSet, waterSet, grassSet, flowerSet]);
        const collisionLayer = map.createLayer('collisions', DEBUG ? [baseSet] : []);
        const treeLayer = map.createLayer('tree', [baseSet, waterSet, grassSet, flowerSet]).setDepth(4096);
        const buildingUpLayer = map.createLayer('building_up', [baseSet, waterSet, grassSet, flowerSet]).setDepth(4096);

        this.creatures = this.physics.add.group();
        this.enemies = this.physics.add.group();
        this.allies = this.physics.add.group();

        //TODO: Добавить загрузку всего из одного файла
        const vagabond = new AllyCreature({
            scene: this,
            x: 960,
            y: 960,
            texture: 'vagabond',
            health: 10,
            damage: 2,
            attackReach: 100,
            speed: 250,
            scale: 2,
            idleAnimation: 'vagabondIdle',
            moveAnimation: 'vagabondMove'
        })

        const priest = new AllyCreature({
            scene: this,
            x: 900,
            y: 960,
            texture: 'vagabond',
            health: 10,
            damage: -2,
            attackReach: 100,
            speed: 250,
            scale: 2,
            idleAnimation: 'vagabondIdle',
            moveAnimation: 'vagabondMove'
        })
        
        this.createMannequinEnemy(600, 1000, 12);

        this.anims.create({
            key:'vagabondMove',
            frames:this.anims.generateFrameNumbers('vagabond', {start:0, end:7}),
            frameRate: 8
        })

        this.anims.create({
            key:'vagabondIdle',
            frames: [{key:'vagabond', frame:16}],
            frameRate: 8
        })

        this.anims.create({
            key:'mannequinMove',
            frames:this.anims.generateFrameNumbers('mannequin', {start:0, end:5}),
            frameRate: 8
        })
        
        this.anims.create({
            key:'mannequinIdle',
            frames:[{key: 'mannequin', frame: 6}],
            frameRate: 8
        })

        this.cursors = this.input.keyboard.createCursorKeys();

        PLAYER = vagabond;

        collisionLayer.setCollision(294);
        this.physics.add.collider(this.creatures, collisionLayer);

        this.cameras.main.startFollow(PLAYER, true, 0.2, 0.2);

        console.log(this)
    }
    update(){
        if (PLAYER.data.values.health <= 0){
            console.log("Вы умерли!")
        }
        
        if (this.cursors.shift.isDown && PLAYER.data.values.attackCooldown == 0){
            if (PLAYER == this.allies.getChildren()[0]){
                setPlayer(this.allies.getChildren()[1]);
                console.log('Меняю на странника!')
            } else {
                setPlayer(this.allies.getChildren()[0]);
                console.log('Меняю на священника!')
            }
            PLAYER.data.values.attackCooldown += 20;
        }
    }
    
    createMannequinEnemy(x, y, health){
        let mannequin = new EnemyCreature({
            scene: this,
            x: x,
            y: y,
            texture: 'mannequin',
            health: health,
            damage: 1,
            attackReach: 50,
            speed: 150,
            scale: 3,
            idleAnimation: 'mannequinIdle',
            moveAnimation: 'mannequinMove'
        })
    }
}

class Creature extends Phaser.Physics.Arcade.Sprite{
    constructor(config){
        super(config.scene, config.x, config.y, config.texture);
        this.scene.add.existing(this);
        this.scene.physics.add.existing(this);
        this.scene.creatures.add(this);

        this.setScale(config.scale);
        this.setBodySize(5, 5)
        this.setOffset(this.width/2 - 5/2, this.height - 5/2)

        this.setData('health', config.health);
        this.setData('damage', config.damage);
        this.setData('speed', config.speed);
        this.setData('attackReach', config.attackReach);
        this.setData('iframes', 0);
        this.setData('attackCooldown', 0);

        this.idleAnimation = config.idleAnimation;
        this.moveAnimation = config.moveAnimation;

        if (DEBUG){
            this.debugPositionPoint = this.scene.add.ellipse(this.body.center.x, this.body.center.y, this.scale*5, this.scale*5, 0xff0000)
        }
    }
    
    takeDamage(damage){
        if (this.data.values.iframes == 0){
            this.data.values.health -= damage;

            this.data.values.iframes = 10;
        };
    }

    attack(target, damage, delay, cooldown){
        if (this.data.values.attackCooldown == 0){
            let hitbox = this.scene.add.rectangle(this.body.center.x, this.body.center.y, this.data.values.attackReach, this.data.values.attackReach, 0x000000, 0.2);
            let hitboxBody = new Phaser.Physics.Arcade.StaticBody(this.scene.physics.world, hitbox);
            let hitboxCollider = this.scene.physics.add.collider(hitbox, target, function(object1, object2){object2.takeDamage(damage)})
            hitbox.body = hitboxBody;

            this.scene.time.delayedCall(delay, function(){hitbox.destroy(); hitboxBody.destroy(); hitboxCollider.destroy();})
            
            this.data.values.attackCooldown = cooldown;
        }
    }
    
    progressEffects(){
        if (this.data.values.iframes > 0){
            this.data.values.iframes -= 1;
        }
        if (this.data.values.attackCooldown>0){
            this.data.values.attackCooldown -= 1;
        }
    }

    playerControl(input){

        let direction = new Phaser.Math.Vector2(0,0);

        if (input.left.isDown){
            direction.x = -1;
        }
        if (input.right.isDown){
            direction.x = 1;
        }
        if (input.up.isDown){
            direction.y = -1;
        }
        if (input.down.isDown){
            direction.y = 1;
        }
        if (input.space.isDown){
            this.attack(this.scene.enemies, this.data.values.damage, 100, 20);
        }
        
        direction.normalize();
        this.body.setVelocity(direction.x * this.data.values.speed, direction.y * this.data.values.speed);
    }
    
    preUpdate(delta, time){
        super.preUpdate(delta, time);
        if (this == PLAYER){

            this.playerControl(this.scene.cursors);
        }

        if (this.body.velocity.x<0){
            this.flipX = true;
        }
        if (this.body.velocity.x>0){
            this.flipX = false;
        }
        if (this.body.velocity.length() == 0){
            this.anims.play(this.idleAnimation, true);
        } else {
            this.anims.play(this.moveAnimation, true);
        }

        this.setDepth(this.body.center.y);
        this.progressEffects();

        if (DEBUG){
            this.debugPositionPoint.setPosition(this.body.center.x, this.body.center.y);
        }
    }
}

class EnemyCreature extends Creature{
    constructor(config){
        super(config);
        this.scene.enemies.add(this);

    }
    preUpdate(delta, time){
        super.preUpdate(delta, time);

        if (PLAYER == this){
            return 0;
        }

        let distanceToPlayer = Phaser.Math.Distance.Between(PLAYER.body.center.x, PLAYER.body.center.y, this.body.center.x, this.body.center.y);
        if (distanceToPlayer < 250 && distanceToPlayer > 50){
            this.scene.physics.moveToObject(this, PLAYER, this.data.values.speed);
        } else {
            this.setVelocity(0);
        }
        if (distanceToPlayer <= 50){
            this.setVelocity(0);
            this.attack(PLAYER, this.data.values.damage, 100, 60);
            if (this.body.center.x > PLAYER.body.center.x){
                this.flipX = true;
            } else {
                this.flipX = false;
            }
        }
    }
}

class AllyCreature extends Creature{
    constructor(config){
        super(config);
        this.scene.allies.add(this);
    }
    preUpdate(delta, time){
        super.preUpdate(delta, time);

        if (PLAYER == this){
            return 0;
        }

        let distanceToPlayer = Phaser.Math.Distance.Between(PLAYER.body.center.x, PLAYER.body.center.y, this.body.center.x, this.body.center.y);
        if (distanceToPlayer>50){
            this.scene.physics.moveToObject(this, PLAYER, this.data.values.speed*0.95)
        } else {
            this.setVelocity(0);
            if (this.body.center.x > PLAYER.body.center.x){
                this.flipX = true;
            } else {
                this.flipX = false;
            }
        }
    }
}

function setPlayer(target){
    PLAYER = target;
    target.scene.cameras.main.startFollow(target);
}

const config = {
    type: Phaser.AUTO,
    width: 1024,
    height: 768,
    physics: {
        default: 'arcade',
        arcade: {
            debug: false
        }
    },
    scene:GameScene
};

const game = new Phaser.Game(config);

</script>
    
</body>
</html>