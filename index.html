<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Делаем игру на Phaser!</title>
    <script src="../node_modules/phaser/dist/phaser.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

var config = {
    type: Phaser.AUTO,
    width: 1024,
    height: 768,
    physics: {
        default: 'arcade',
        arcade: {
            debug: false
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

var game = new Phaser.Game(config);

function preload ()
{
    this.load.spritesheet('vagabond', 'src/vagabond.png', {frameWidth:64, frameHeight:64});
    this.load.spritesheet('man', 'src/mannequin.png', {frameWidth:48, frameHeight: 48})
    this.load.image('sky', 'src/sky.png')

    this.load.image('base', 'src/SampleMap/[Base]BaseChip_pipo.png')
    this.load.image('water', 'src/SampleMap/[A]Water_pipo.png')
    this.load.image('grass', 'src/SampleMap/[A]Grass_pipo.png')
    this.load.image('flower', 'src/SampleMap/[A]Flower_pipo.png')
    this.load.tilemapTiledJSON('samplemap', 'src/SampleMap/samplemap.json')
}

var speed = 200;
var isTurned = false;
var positionText;
var seconds = 0;

function create ()
{
    map = this.add.tilemap('samplemap' );

    const baseSet = map.addTilesetImage('[Base]BaseChip_pipo', 'base');
    const waterSet = map.addTilesetImage('[A]Water_pipo', 'water');
    const grassSet = map.addTilesetImage('[A]Grass_pipo', 'grass');
    const flowerSet = map.addTilesetImage('[A]Flower_pipo', 'flower');

    const groundLayer = map.createLayer('ground', [baseSet, waterSet, grassSet, flowerSet]);
    const grassLayer = map.createLayer('grass', [baseSet, waterSet, grassSet, flowerSet]);
    const waterLayer = map.createLayer('water', [baseSet, waterSet, grassSet, flowerSet]);
    const waterGrassLayer = map.createLayer('water_grass', [baseSet, waterSet, grassSet, flowerSet]);
    const buildingLayer = map.createLayer('building', [baseSet, waterSet, grassSet, flowerSet]);
    const farmLayer = map.createLayer('farm', [baseSet, waterSet, grassSet, flowerSet]);
    const farmUpLayer = map.createLayer('farm_up', [baseSet, waterSet, grassSet, flowerSet]);
    const collisionLayer = map.createLayer('collisions', []);
    
    player = this.physics.add.sprite(1200, 1000, 'vagabond').setScale(2);
    enemies = this.physics.add.group();
    enemy = enemies.create(1300, 1000, 'man', 6, true, true).setScale(2)
    
    const treeLayer = map.createLayer('tree', [baseSet, waterSet, grassSet, flowerSet]);
    const buildingUpLayer = map.createLayer('building_up', [baseSet, waterSet, grassSet, flowerSet]);
    
    // Создадим игрока и расположим его в заданных координатах
    player.setBodySize(10,10)
    player.setOffset(27,57)

    //  Наши анмации.
    this.anims.create({
        key: 'playerMoveLeft',
        frames: this.anims.generateFrameNumbers('vagabond', { start: 8, end: 15 }),
        frameRate: 10,
        repeat: -1,
    });

    this.anims.create({
        key: 'playerIdleRight',
        frames: [ { key: 'vagabond', frame: 17 } ],
        frameRate: 20
    });
    
    this.anims.create({
        key: 'playerIdleLeft',
        frames: [ { key: 'vagabond', frame: 16 } ],
        frameRate: 20
    });

    this.anims.create({
        key: 'playerMoveRight',
        frames: this.anims.generateFrameNumbers('vagabond', { start: 0, end: 7 }),
        frameRate: 10,
        repeat: -1
    });

    this.anims.create({
        key: 'enemyMoveRight',
        frames: this.anims.generateFrameNumbers('man', { start: 0, end: 5 }),
        frameRate: 8,
        repeat: -1
    });

    this.anims.create({
        key: 'enemyMoveLeft',
        frames: this.anims.generateFrameNumbers('man', { start: 12, end: 7 }),
        frameRate: 8,
        repeat: -1
    });
    
    this.anims.create({
        key: 'enemyIdle',
        frames: [ { key: 'man', frame: 6 } ],
        frameRate: 8,
        repeat: -1
    });

    //  Отслеживание нажатий
    cursors = this.input.keyboard.createCursorKeys();
    positionText = this.add.text(16,16, 'Position: '+player.x+' '+player.y)
    positionText.scrollFactorX = 0
    positionText.scrollFactorY = 0

    enemy.setBodySize(15, 15);
    enemy.setOffset(16, 38);
    enemy.setData('health', 7);
    enemy.setData('iframes', 10);
    enemytext = this.add.text(enemy.x, enemy.y - 20, enemy.getData('health'))

    collisionLayer.setCollision(294)
    this.physics.add.collider(player, collisionLayer)
    this.physics.add.collider(enemies, collisionLayer)

    playercircle = this.add.ellipse(player.body.center.x, player.body.center.y, 10, 10, 0xff0000)
    enemycircle = this.add.ellipse(enemy.x, enemy.y, 15, 15, 0x0000ff)

    player.setData('attackCooldown', 0)
}

function update ()
{
    playerMoveDirection = getDirections(cursors, this) 
    
    player.setVelocity(playerMoveDirection.x * speed, playerMoveDirection.y * speed)
    
    if (playerMoveDirection.length()>0){
        if (isTurned){
            player.anims.play('playerMoveLeft', true)
        } else{
            player.anims.play('playerMoveRight', true)
        }
    } else {
        isTurned ? player.anims.play('playerIdleRight', true) : player.anims.play('playerIdleLeft', true)
    }

    positionText.setText('Position: '+player.x+' '+player.y);
    enemytext.setText(enemy.getData('health'));
    enemytext.setPosition(enemy.x, enemy.y - 20)
    
    this.cameras.main.startFollow(player, true, 0.1, 0.1);
    enemyLogic(this, enemy, player);
    //11 - up, 12 - down, 13 -  left, 14 - right
    // console.log(player.body.facing)
    playercircle.setPosition(player.body.center.x, player.body.center.y)
    enemycircle.setPosition(enemy.body.center.x, enemy.body.center.y)

    if (player.getData('attackCooldown')>0){
        player.setData('attackCooldown', player.getData('attackCooldown') - 1)
    }
}
function getDirections(cursors, scene){
    let direction = new Phaser.Math.Vector2(0,0);

    if (cursors.left.isDown)
    {
        direction.x = -1;
        isTurned = true;
    }
    if (cursors.right.isDown)
    {
        direction.x = 1;
        isTurned = false;
    }
    if (cursors.up.isDown)
    {
        direction.y = -1;
    }
    if (cursors.down.isDown)
    {
        direction.y = 1;
    }
    if (cursors.shift.isDown){
        heal(player, enemy, scene);
    }
    if (cursors.space.isDown){
        attack(player, enemy, scene);
    }
    direction.normalize()
    return direction
}
function enemyLogic(scene, enemy, player){

    if (Phaser.Math.Distance.Between(enemy.body.x, enemy.body.y, player.body.x, player.body.y)<100){
        enemy.setVelocity(0);
        // console.log('AAAAAAAAAA!')
    } else {
        scene.physics.moveTo(enemy, player.body.x, player.body.y-enemy.height, speed*0.9);
    }

    enemy.flipX = false;
    if (enemy.body.velocity.x > 0){
        enemy.setData('turned', true);
    } 
    if(enemy.body.velocity.x < 0) {
        enemy.setData('turned', false);
    }
    if (enemy.body.velocity.length()>0){
        if(enemy.getData('turned')){
            enemy.anims.play('enemyMoveRight', true);
        } else {
            enemy.anims.play('enemyMoveLeft', true);
        }
    } else {
        enemy.anims.play('enemyIdle', true)
        enemy.getData('turned') ? enemy.flipX = false : enemy.flipX = true;
    }
    if (enemy.getData('health') == 0){
        console.log("Enemy is Dead!");
        enemy.setData('health', Phaser.Math.Between(-10, 10));
        randomTeleportEnemy(enemy);
    }
    if (enemy.getData('health') < 0 ){
        enemy.setTint(0x880088)
    }
    else{
        enemy.clearTint();
    }
    if (enemy.getData('iframes')>0){
        enemy.data.values.iframes -= 1;
    }
}
function randomTeleportEnemy(enemy){
    while (Phaser.Math.Distance.Between(enemy.x, enemy.y, player.x, player.y)<300){
        enemy.setPosition(Phaser.Math.Between(0, 1900), Phaser.Math.Between(0, 1900));
    }
}
function attack(player, target, scene){
    if (player.getData('attackCooldown') == 0){
        hitbox = scene.add.rectangle(player.body.x, player.body.y, 100, 100, 0xff0000, 0.2);
        hitboxBody = new Phaser.Physics.Arcade.StaticBody(scene.physics.world, hitbox);
        hitboxCollider = scene.physics.add.collider(hitbox, target, function(){takeDamage(target, -2)}, null, scene);
        hitbox.body = hitboxBody;
        
        scene.time.delayedCall(100, function(){hitbox.destroy()});
        
        player.setData('attackCooldown', 20);
    }
}
function heal(player, target, scene){
    if (player.getData('attackCooldown') == 0){
        healbox = scene.add.rectangle(player.body.x, player.body.y, 100, 100, 0x00ff00, 0.2);
        healboxBody = new Phaser.Physics.Arcade.StaticBody(scene.physics.world, healbox);
        healboxCollider = scene.physics.add.collider(healbox, target, function(){takeDamage(target, 3)}, null, scene);
        healbox.body = healboxBody;
        
        scene.time.delayedCall(100, function(){healbox.destroy()});
        
        player.setData('attackCooldown', 20);
    }
}

function takeDamage(target, damage){
    if (target.data.values.iframes == 0){
        target.setData('health', target.getData('health') + damage)
        target.data.values.iframes += 10;
    }
}
function placeholder(){
    console.log('placeholder!');
}

</script>

</body>
</html>