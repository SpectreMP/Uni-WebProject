<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Math warriors</title>
    <script src="node_modules/phaser/dist/phaser.min.js"></script>
    <style type="text/css">
        body{
            margin: 0;
        }
    </style>
</head>
<body>
<script type="text/javascript">
var PLAYER;
var DEBUG = false;

class GameScene extends Phaser.Scene{
    preload(){
        this.load.spritesheet('vagabond', 'src/vagabond.png', {frameWidth:64});
        this.load.spritesheet('priest', 'src/priest.png', {frameWidth:64});
        this.load.spritesheet('mannequin', 'src/mannequin_spritesheet.png', {frameWidth:48})
        this.load.spritesheet('slash', 'src/slash.png', {frameWidth: 275, frameHeight: 200})

        this.load.image('base', 'src/SampleMap/[Base]BaseChip_pipo.png')
        this.load.image('water', 'src/SampleMap/[A]Water_pipo.png')
        this.load.image('grass', 'src/SampleMap/[A]Grass_pipo.png')
        this.load.image('flower', 'src/SampleMap/[A]Flower_pipo.png')
        this.load.tilemapTiledJSON('samplemap', 'src/SampleMap/samplemap.json')
    }
    create(){
        const map = this.add.tilemap('samplemap' );

        const baseSet = map.addTilesetImage('[Base]BaseChip_pipo', 'base');
        const waterSet = map.addTilesetImage('[A]Water_pipo', 'water');
        const grassSet = map.addTilesetImage('[A]Grass_pipo', 'grass');
        const flowerSet = map.addTilesetImage('[A]Flower_pipo', 'flower');

        const groundLayer = map.createLayer('ground', [baseSet, waterSet, grassSet, flowerSet]);
        const grassLayer = map.createLayer('grass', [baseSet, waterSet, grassSet, flowerSet]);
        const waterLayer = map.createLayer('water', [baseSet, waterSet, grassSet, flowerSet]);
        const waterGrassLayer = map.createLayer('water_grass', [baseSet, waterSet, grassSet, flowerSet]);
        const buildingLayer = map.createLayer('building', [baseSet, waterSet, grassSet, flowerSet]);
        const farmLayer = map.createLayer('farm', [baseSet, waterSet, grassSet, flowerSet]);
        const farmUpLayer = map.createLayer('farm_up', [baseSet, waterSet, grassSet, flowerSet]);
        const collisionLayer = map.createLayer('collisions', DEBUG ? [baseSet] : []);
        const treeLayer = map.createLayer('tree', [baseSet, waterSet, grassSet, flowerSet]).setDepth(4096);
        const buildingUpLayer = map.createLayer('building_up', [baseSet, waterSet, grassSet, flowerSet]).setDepth(4096);

        this.creatures = this.physics.add.group();
        this.enemies = this.physics.add.group();
        this.allies = this.physics.add.group();

        //TODO: Добавить загрузку всего из одного файла
        const vagabond = new AllyCreature({
            scene: this,
            x: 260,
            y: 400,
            texture: 'vagabond',
            health: 10,
            damage: 2,
            attackReach: 150,
            speed: 250,
            scale: 2,
            idleAnimation: 'vagabondIdle',
            moveAnimation: 'vagabondMove',
            attackAnimation: 'slash',
            deathAnimation: 'vagabondIdle'
        })

        const priest = new AllyCreature({
            scene: this,
            x: 200,
            y: 400,
            texture: 'vagabond',
            health: 10,
            damage: -3,
            attackReach: 150,
            speed: 250,
            scale: 2,
            idleAnimation: 'priestIdle',
            moveAnimation: 'priestMove',
            attackAnimation: 'slash',
            deathAnimation: 'priestIdle'
        })
        
        this.createMannequinEnemy(400, 960, 7);
        this.createMannequinEnemy(280, 920, -4);
        const boss = this.createMannequinEnemy(1720, 1720, 13);
        boss.setScale(4);
        boss.data.values.damage = 2;

        this.anims.create({
            key:'vagabondMove',
            frames:this.anims.generateFrameNumbers('vagabond', {start:0, end:7}),
            frameRate: 8
        })

        this.anims.create({
            key:'vagabondIdle',
            frames: [{key:'vagabond', frame:8}],
            frameRate: 8
        })

        this.anims.create({
            key:'priestMove',
            frames:this.anims.generateFrameNumbers('priest', {start:0, end:7}),
            frameRate: 8
        })

        this.anims.create({
            key:'priestIdle',
            frames: [{key:'priest', frame:8}],
            frameRate: 8
        })

        this.anims.create({
            key:'mannequinMove',
            frames:this.anims.generateFrameNumbers('mannequin', {start:20, end:25}),
            frameRate: 8
        })
        
        this.anims.create({
            key:'mannequinIdle',
            frames:[{key: 'mannequin', frame: 3}],
            frameRate: 8
        })

        this.anims.create({
            key:'mannequinDeath',
            frames:this.anims.generateFrameNumbers('mannequin', {start:90, end:95}),
            frameRate: 8
        })

        this.anims.create({
            key: 'slash',
            frames: this.anims.generateFrameNumbers('slash', {start:0, end: 5}),
            showOnStart: true,
            hideOnComplete: true
        })

        this.cursors = this.input.keyboard.createCursorKeys();

        PLAYER = vagabond;

        collisionLayer.setCollision(294);
        this.physics.add.collider(this.creatures, collisionLayer);
        this.physics.add.collider(this.enemies, this.enemies);

        this.cameras.main.startFollow(PLAYER, true, 0.2, 0.2);

        console.log(this)
    }
    update(){
        if (PLAYER.data.values.health <= 0){
            console.log("Вы умерли!")
        }
        
        if (this.cursors.shift.isDown && PLAYER.data.values.attackCooldown == 0){
            if (PLAYER == this.allies.getChildren()[0]){
                setPlayer(this.allies.getChildren()[1]);
            } else {
                setPlayer(this.allies.getChildren()[0]);
            }
            PLAYER.data.values.attackCooldown += 20;
        }
    }
    
    createMannequinEnemy(x, y, health){
        let mannequin = new EnemyCreature({
            scene: this,
            x: x,
            y: y,
            texture: 'mannequin',
            health: health,
            damage: 1,
            attackReach: 100,
            speed: 150,
            scale: 3,
            idleAnimation: 'mannequinIdle',
            moveAnimation: 'mannequinMove',
            attackAnimation: 'slash',
            deathAnimation: 'mannequinDeath'
        })
        return mannequin;
    }
}

class Creature extends Phaser.Physics.Arcade.Sprite{
    constructor(config){
        super(config.scene, config.x, config.y, config.texture);
        this.scene.add.existing(this);
        this.scene.physics.add.existing(this);
        this.scene.creatures.add(this);

        this.setScale(config.scale);
        this.setBodySize(5, 5)
        this.setOffset(this.width/2 - 5/2, this.height - 5/2)

        this.setData('health', config.health);
        this.setData('damage', config.damage);
        this.setData('speed', config.speed);
        this.setData('attackReach', config.attackReach);
        this.setData('iframes', 0);
        this.setData('attackCooldown', 0);
        this.setData('isDead', false);

        this.idleAnimation = config.idleAnimation;
        this.moveAnimation = config.moveAnimation;
        this.attackAnimation = config.attackAnimation;
        this.deathAnimation = config.deathAnimation;

        if (DEBUG){
            this.debugPositionPoint = this.scene.add.ellipse(this.body.center.x, this.body.center.y, this.scale*5, this.scale*5, 0xff0000)
        }
    }
    
    takeDamage(damage){
        if (this.data.values.iframes == 0){
            this.data.values.health -= damage;

            this.data.values.iframes = 20;
        };
        if (this.data.values.health == 0){
            this.data.values.isDead = true;
        }
    }

    attack(target, damage, delay, cooldown){
        if (this.data.values.attackCooldown == 0){
            this.scene.time.delayedCall(delay, function(){
                let hitbox = this.scene.add.rectangle(this.body.center.x + (this.flipX ? -this.width : this.width), this.body.center.y, this.data.values.attackReach, this.data.values.attackReach, 0x000000, 0);
                let hitboxBody = new Phaser.Physics.Arcade.StaticBody(this.scene.physics.world, hitbox);
                let hitboxCollider = this.scene.physics.add.overlap(hitbox, target, function(object1, object2){object2.takeDamage(damage)})
                hitbox.body = hitboxBody;

                this.scene.time.delayedCall(200, function(){hitbox.destroy(); hitboxBody.destroy(); hitboxCollider.destroy();})
            }, null, this)
            
            this.data.values.attackCooldown = cooldown;

            let slash = this.scene.add.sprite(this.body.center.x, this.body.center.y - this.height/2, 'slash').setDepth(this.body.center.y+1)
            if (this.flipX){
                slash.flipX = true;
            }
            slash.anims.play('slash');
        }
    }
    
    progressEffects(){
        if (this.data.values.iframes > 0){
            this.data.values.iframes -= 1;
        }
        if (this.data.values.attackCooldown>0){
            this.data.values.attackCooldown -= 1;
        }
    }

    playerControl(input){

        let direction = new Phaser.Math.Vector2(0,0);

        if (input.left.isDown){
            direction.x = -1;
        }
        if (input.right.isDown){
            direction.x = 1;
        }
        if (input.up.isDown){
            direction.y = -1;
        }
        if (input.down.isDown){
            direction.y = 1;
        }
        if (input.space.isDown){
            this.attack(this.scene.enemies, this.data.values.damage, 0, 20);
        }
        
        direction.normalize();
        this.body.setVelocity(direction.x * this.data.values.speed, direction.y * this.data.values.speed);
    }
    
    preUpdate(delta, time){
        super.preUpdate(delta, time);

        if (this.data.values.isDead){
            this.setVelocity(0);
            this.anims.play(this.deathAnimation, true);
            if (this.anims.currentFrame.isLast){
                this.removeFromUpdateList();
            }
            return 0;
        }

        if (this == PLAYER){
            this.playerControl(this.scene.cursors);
        }

        if (this.body.velocity.x<0){
            this.flipX = true;
        }
        if (this.body.velocity.x>0){
            this.flipX = false;
        }
        if (this.body.velocity.length() == 0){
            this.anims.play(this.idleAnimation, true);
        } else {
            this.anims.play(this.moveAnimation, true);
        }

        this.setDepth(this.body.center.y);
        this.progressEffects();

        if (DEBUG){
            this.debugPositionPoint.setPosition(this.body.center.x, this.body.center.y);
        }
    }
}

class EnemyCreature extends Creature{
    constructor(config){
        super(config);
        this.scene.enemies.add(this);

        this.healthbar = this.scene.add.text(this.x, this.y-this.height/2, this.data.values.health, { fontSize: '20px', color: '#ffffff', strokeThickness: 1, stroke: '#000'});
    }
    preUpdate(delta, time){
        super.preUpdate(delta, time);
        
        this.healthbar.setPosition(this.x-this.healthbar.width/2, this.y-this.height/2);
        this.healthbar.setText(this.data.values.health);
        if (this.data.values.health>0){
            this.healthbar.setColor('#fff');
        } else {
            this.healthbar.setColor('#b6b');
        }

        if (this.data.values.isDead){
            this.healthbar.setText('')
            return 0;
        }

        if (this.data.values.health>0){
            this.clearTint();
        } else {
            this.setTint(0xbb66bb)
        }

        if (PLAYER == this){
            return 0;
        }

        let distanceToPlayer = Phaser.Math.Distance.Between(PLAYER.body.center.x, PLAYER.body.center.y, this.body.center.x, this.body.center.y);
        if (distanceToPlayer < 250 && distanceToPlayer > 50){
            this.scene.physics.moveToObject(this, PLAYER, this.data.values.speed);
        } else {
            this.setVelocity(0);
        }
        if (distanceToPlayer <= 50){
            this.setVelocity(0);
            this.attack(PLAYER, this.data.values.damage, 400, 60);
            if (this.body.center.x > PLAYER.body.center.x){
                this.flipX = true;
            } else {
                this.flipX = false;
            }
        }
    }
}

class AllyCreature extends Creature{
    constructor(config){
        super(config);
        this.scene.allies.add(this);
    }
    preUpdate(delta, time){
        super.preUpdate(delta, time);

        if (this.data.values.iframes>0){
            
        }

        if (PLAYER == this){
            return 0;
        }

        let distanceToPlayer = Phaser.Math.Distance.Between(PLAYER.body.center.x, PLAYER.body.center.y, this.body.center.x, this.body.center.y);
        if (distanceToPlayer>50){
            this.scene.physics.moveToObject(this, PLAYER, this.data.values.speed*0.95)
        } else {
            this.setVelocity(0);
            if (this.body.center.x > PLAYER.body.center.x){
                this.flipX = true;
            } else {
                this.flipX = false;
            }
        }
    }
}

function setPlayer(target){
    PLAYER = target;
    target.scene.cameras.main.startFollow(target);
}

class Menu extends Phaser.Scene{
    preload(){

    }
    create(){
        this.add.text(140, 384, "PRESS SPACE TO START", { fontSize: '62px', color: '#ffffff', strokeThickness: 1, stroke: '#000'})
        this.cursors = this.input.keyboard.createCursorKeys();
    }
    update(){
        if (this.cursors.space.isDown){
            this.scene.start('level1');
        }
    }
}

const config = {
    type: Phaser.AUTO,
    width: 1024,
    height: 768,
    physics: {
        default: 'arcade',
        arcade: {
            debug: false
        }
    },
    scene:Menu
};

const game = new Phaser.Game(config);
game.scene.add('level1', GameScene)

</script>
    
</body>
</html>